# 🎨 AI 에이전트를 위한 자연스러운 글쓰기 가이드

## 🎯 핵심 목표

**AI가 써도 사람이 쓴 것 같은 자연스러운 글 작성**

## 🚨 절대 준수 사항

1. **절대 추측하지 말 것** - 모든 정보는 정확히 확인
2. **순서대로 진행** - 단계를 건너뛰면 실패
3. **스키마 필드 완전 활용** - MainPost 테이블의 모든 필드 사용

## 🎨 자연스러운 글쓰기 핵심 원칙

### 📝 문단 간격의 중요성

**글쓰기에서 호흡이 중요합니다:**
- 모든 내용을 한번에 쏟아내면 독자가 압박감을 느낌
- 적절한 문단 간격으로 읽기 편한 리듬 생성
- 생각을 전환하는 지점에서 자연스럽게 띄우기
- `<빈 줄>` 표시 위치에서 실제로 한 줄 띄우기

<빈 줄>

**문단 띄우기 기준:**
- 주제가 전환될 때
- 새로운 예시나 사례를 들 때
- 감정이나 톤이 바뀔 때
- 독자가 잠시 생각할 시간이 필요할 때

### 🎯 자연스러운 글쓰기 핵심 원칙

**❌ 피해야 할 AI 티 나는 요소들:**
- 1,2,3 기계적 나열과 "따라서", "그러므로" 딱딱한 연결어
- "여러분, 혹시 ~" 뻔한 호명과 과도한 존댓말
- ✅❌ 이분법적 정리와 감정 없는 로봇 같은 객관성

**✅ 자연스럽게 만드는 방법:**
- **구조**: 기계적 나열 → 자연스러운 문단 전개 + 감정/직관 섞인 전개
- **문체**: "그런데", "사실" 같은 자연스러운 전환 + 격식체와 구어체 적절히 혼합
- **내용**: 추상적 설명 → 구체적 경험/사례 + 작성자의 솔직한 관점

### 🔍 실제 변환 예시

**❌ AI 티 나는 버전:**
```
이 도구는 개발자들에게 많은 효율성을 제공합니다.
주요 특징은 다음과 같습니다:
1. 빠른 처리 속도
2. 직관적인 사용법  
3. 뛰어난 호환성
따라서 업무 효율성이 크게 향상될 것입니다.
```

**✅ 자연스러운 버전:**
```
개발자 입장에서 보면, 이거 하나로 업무 시간이 확 줄어들 것 같아요.

<빈 줄>

실제로 써보니:
- 속도가 생각보다 빠름 (기존 툴 쓸 때 답답했던 게 이해됨)
- 설정도 복잡하지 않고, 금방 적응됨
- 기존 프로젝트에 바로 적용 가능

<빈 줄>

솔직히 처음엔 반신반의했는데, 막상 써보니까 꽤 괜찮더라고요.
```

## 📝 범용 자연스러운 글 템플릿

### 기본 범용 템플릿 (모든 주제에 적용 가능)

```markdown
# [궁금증을 자극하는 자연스러운 제목]

사실 처음 [이 주제]에 대해 들었을 때는 '또 그런 거겠지' 싶었습니다.

<빈 줄>

그런데 실제로 알아보니까...

<빈 줄>

## 🔍 왜 이게 주목받고 있을까요?

[독자층]이라면 이런 상황 겪어보셨을 거예요.

<빈 줄>

[구체적이고 공감 가는 상황 설명]

<빈 줄>

그런데 이번에 [다룰 주제/제품/현상]은 좀 다른 접근을 하더라고요.

## 💡 실제로는 어떤 건지

### [핵심 포인트 1] - 이게 진짜 인상적이었음

기존에 우리가 [관련 일]을 할 때 보통 이랬잖아요?

<빈 줄>

1. [기존 방식을 자연스럽게 설명]
2. 그러면서 중간중간 막히는 부분들...
3. 결국 [시간/비용/노력] 많이 들고

<빈 줄>

그런데 [새로운 방식/제품/방법]으로는 정말 달라집니다.

<빈 줄>

**실제로 경험해보니:**
- [구체적 개선점 1] (숫자가 있으면 더 좋음)
- [구체적 개선점 2] 
- [구체적 개선점 3]

<빈 줄>

### [핵심 포인트 2] - 이 부분도 괜찮네요

사실 이런 류의 [제품/서비스/방법]들이 보통 [흔한 문제점]이 있거든요.

<빈 줄>

그런데 생각보다 이런 부분들이 잘 해결되어 있더라고요.

## 📊 실제 경험해본 사람들 반응

### [구체적 집단]에서 [기간] 써본 결과

[구체적 사례나 후기를 자연스럽게]

<빈 줄>

**Before:** [기존 상황을 구체적 수치나 상황과 함께]
**After:** [개선된 결과를 구체적으로]

<빈 줄>

물론 완벽하지는 않아요.

<빈 줄>

### 좋았던 점들

**확실히 개선된 부분:**
- [구체적 장점 1] - [수치나 상황]으로 표현
- [구체적 장점 2] - 특히 [상황]에서 유용함
- [구체적 장점 3] - [기존 방법] 쓸 때보다 편함

<빈 줄>

### 아직 아쉬운 부분들

**개선이 필요한 점:**
- [구체적 단점 1] - [언제/어떤 상황]에서 문제됨
- [구체적 단점 2] - 아직 [특정 부분] 부족함
- [구체적 단점 3] - [비용/접근성] 관련 이슈

## 🚀 실제로 해보고 싶다면

### 가장 간단한 시작 방법

복잡한 준비 필요 없고, 이렇게 하시면 됩니다.

**1단계:** [구체적인 첫 단계]
**2단계:** [구체적인 두 번째 단계]
**3단계:** [구체적인 세 번째 단계]

### 주의할 점들

처음 시도하시는 분들이 자주 실수하는 부분들이 있어요.

- [주의사항 1] - [구체적 상황과 해결법]
- [주의사항 2] - [흔한 실수와 피하는 법]

## 🤔 결론적으로는...

개인적으로는 [솔직한 개인 의견].

완벽한 해답은 아니지만, [특정 상황이나 대상]에게는 확실히 도움이 될 것 같네요.

특히 [구체적 대상]분들에게는 한 번 시도해볼 만하다고 생각합니다.

여러분은 어떻게 보시나요? 비슷한 경험 있으시거나 궁금한 점 있으시면 댓글로 얘기해봐요!
```

### 개발 분야별 적용 예시

#### 🤖 AI뉴스 카테고리
```markdown
# GPT-5 베타 써보니 진짜 개발자 대체할 수 있겠더라

사실 처음 GPT-5 베타 소식 들었을 때는 '또 그런 마케팅이겠지' 싶었어요.

그런데 실제로 써보니까...

## 🔍 왜 이게 주목받고 있을까요?

개발자분들이라면 이런 상황 겪어보셨을 거예요:
- AI 코딩 도구 써도 결국 수정할 게 많고
- 복잡한 로직은 여전히 직접 짜야 하고
- "AI가 개발자 대체한다"는 말에 반신반의하고...

그런데 이번 GPT-5는 좀 다른 접근을 하더라고요.
```

#### 💻 Frontend 카테고리  
```markdown
# React 19 정식 출시, 실제 프로젝트에 적용해본 후기

솔직히 React 19 소식 처음 봤을 때는 "또 업데이트네" 정도였어요.

그런데 막상 프로젝트에 적용해보니...

## 🔍 실제로는 어떤 건지

프론트엔드 개발하시는 분들이라면:
- 상태 관리 때문에 머리 아픈 적 있으시죠?
- 리렌더링 최적화 신경 쓰느라 지치고
- 새 기능 나와도 안정성 때문에 망설이고...

**실제로 경험해보니:**
- 상태 관리가 확실히 간단해짐
- 성능도 체감될 정도로 개선
- 기존 프로젝트 마이그레이션도 생각보다 수월
```

#### 🔧 Backend 카테고리
```markdown
# Spring Boot 3.3에서 이거 하나로 API 성능 2배 향상

 Virtual Threads 얘기 처음 들었을 때 "이론적으로만 좋은 거 아닌가" 했거든요.

그런데 실제 프로덕션에 적용해보니까...

## 💡 왜 이렇게 성능이 좋아졌을까

백엔드 개발하시는 분들 이런 경험 있으시죠:
- Thread Pool 튜닝하느라 시간 보내고
- 동시 처리 때문에 스트레스받고
- 트래픽 급증할 때마다 불안하고...

**Before vs After:**
- 동시 요청 처리: 500 → 1200개
- 응답 시간: 평균 200ms → 80ms  
- 메모리 사용량: 30% 감소
```

## 🏷️ 개발 관련 태그 색상 가이드

```typescript
const TAG_COLORS = {
  // AI/ML
  AI: '#8b5cf6',
  ChatGPT: '#10a37f', 
  Claude: '#d97706',
  'Gemini': '#059669',
  'GPT-4': '#10a37f',
  'Machine Learning': '#8b5cf6',
  'Deep Learning': '#7c3aed',
  'LLM': '#8b5cf6',
  'Computer Vision': '#7c3aed',
  'NLP': '#d97706',
  
  // 프로그래밍 언어
  JavaScript: '#f59e0b',
  TypeScript: '#3b82f6',
  Python: '#059669',
  Java: '#dc2626',
  Kotlin: '#8b5cf6',
  Go: '#06b6d4',
  Rust: '#dc2626',
  PHP: '#8b5cf6',
  Swift: '#f59e0b',
  'C++': '#6b7280',
  'C#': '#8b5cf6',
  'Ruby': '#dc2626',
  'Scala': '#dc2626',
  'Dart': '#06b6d4',
  
  // Frontend 프레임워크/라이브러리
  React: '#06b6d4',
  'Next.js': '#000000',
  Vue: '#059669',
  'Vue 3': '#059669',
  'Nuxt.js': '#059669',
  Angular: '#dc2626',
  Svelte: '#f59e0b',
  'SvelteKit': '#f59e0b',
  'Remix': '#000000',
  'Astro': '#f59e0b',
  'Vite': '#8b5cf6',
  'Webpack': '#0ea5e9',
  'Tailwind CSS': '#06b6d4',
  'Styled Components': '#ec4899',
  'Emotion': '#ec4899',
  'SCSS/Sass': '#ec4899',
  
  // Backend 프레임워크
  SpringBoot: '#059669',
  Spring: '#059669',
  Django: '#059669',
  FastAPI: '#059669',
  Flask: '#6b7280',
  Express: '#6b7280',
  NestJS: '#dc2626',
  'Ruby on Rails': '#dc2626',
  'ASP.NET': '#8b5cf6',
  'Laravel': '#dc2626',
  'Symfony': '#6b7280',
  'Gin': '#06b6d4',
  'Fiber': '#06b6d4',
  'Actix': '#dc2626',
  
  // 데이터베이스
  PostgreSQL: '#3b82f6',
  MySQL: '#0ea5e9',
  MongoDB: '#059669',
  Redis: '#dc2626',
  Firebase: '#f59e0b',
  'Firestore': '#f59e0b',
  'Supabase': '#059669',
  'PlanetScale': '#000000',
  'DynamoDB': '#f59e0b',
  'Elasticsearch': '#f59e0b',
  'InfluxDB': '#0ea5e9',
  'CockroachDB': '#3b82f6',
  'SQLite': '#0ea5e9',
  'MariaDB': '#7c2d12',
  
  // DevOps/인프라
  Docker: '#0ea5e9',
  Kubernetes: '#3b82f6',
  'Docker Compose': '#0ea5e9',
  AWS: '#f59e0b',
  'AWS Lambda': '#f59e0b',
  'AWS ECS': '#f59e0b',
  'AWS RDS': '#f59e0b',
  Azure: '#3b82f6',
  GCP: '#059669',
  Vercel: '#000000',
  Netlify: '#06b6d4',
  Nginx: '#059669',
  Apache: '#dc2626',
  'Jenkins': '#6b7280',
  'GitHub Actions': '#6b7280',
  'GitLab CI': '#f59e0b',
  'Terraform': '#8b5cf6',
  'Ansible': '#dc2626',
  'Prometheus': '#f59e0b',
  'Grafana': '#f59e0b',
  
  // 개발 도구
  Git: '#f59e0b',
  GitHub: '#6b7280',
  GitLab: '#f59e0b',
  VSCode: '#3b82f6',
  'IntelliJ IDEA': '#dc2626',
  'WebStorm': '#06b6d4',
  'PyCharm': '#059669',
  Postman: '#f59e0b',
  Insomnia: '#8b5cf6',
  'Thunder Client': '#8b5cf6',
  'Swagger': '#059669',
  'Figma': '#ec4899',
  'Notion': '#6b7280',
  'Slack': '#8b5cf6',
  'Discord': '#8b5cf6',
  
  // 개발 방법론 & 아키텍처
  TDD: '#dc2626',
  BDD: '#dc2626',
  DDD: '#dc2626',
  'Clean Code': '#059669',
  'Clean Architecture': '#059669',
  'Hexagonal Architecture': '#059669',
  Microservices: '#3b82f6',
  'Monolithic': '#6b7280',
  'Event Sourcing': '#8b5cf6',
  CQRS: '#8b5cf6',
  'Serverless': '#f59e0b',
  'JAMstack': '#ec4899',
  
  // API & 통신
  API: '#8b5cf6',
  'REST API': '#059669',
  GraphQL: '#ec4899',
  'gRPC': '#0ea5e9',
  'WebSocket': '#8b5cf6',
  'Server-Sent Events': '#6b7280',
  'JSON': '#f59e0b',
  'XML': '#dc2626',
  'YAML': '#8b5cf6',
  
  // 테스팅
  Jest: '#dc2626',
  'React Testing Library': '#dc2626',
  Cypress: '#059669',
  Playwright: '#8b5cf6',
  'Selenium': '#059669',
  'JUnit': '#dc2626',
  'TestNG': '#dc2626',
  'PyTest': '#059669',
  'Mocha': '#7c2d12',
  'Chai': '#dc2626',
  
  // 성능/최적화/보안
  Performance: '#dc2626',
  Optimization: '#f59e0b',
  Security: '#7c2d12',
  'Web Vitals': '#059669',
  'Lighthouse': '#f59e0b',
  SEO: '#8b5cf6',
  'A11y': '#059669',
  'PWA': '#3b82f6',
  'Service Worker': '#3b82f6',
  'Web Assembly': '#8b5cf6',
  
  // 상태관리
  Redux: '#8b5cf6',
  'Redux Toolkit': '#8b5cf6',
  Zustand: '#7c2d12',
  Recoil: '#06b6d4',
  'Context API': '#06b6d4',
  MobX: '#f59e0b',
  Vuex: '#059669',
  Pinia: '#f59e0b',
  
  // UI/UX 라이브러리
  'Material-UI': '#3b82f6',
  'Ant Design': '#0ea5e9',
  'Chakra UI': '#06b6d4',
  'React Bootstrap': '#8b5cf6',
  'Mantine': '#0ea5e9',
  'Headless UI': '#6b7280',
  'Radix UI': '#000000',
  'shadcn/ui': '#000000',
  
  // 모바일
  'React Native': '#06b6d4',
  Flutter: '#0ea5e9',
  'Flutter Web': '#0ea5e9',
  'Ionic': '#0ea5e9',
  'Expo': '#000000',
  
  // 데이터 처리
  'Pandas': '#059669',
  'NumPy': '#3b82f6',
  'Apache Kafka': '#000000',
  'RabbitMQ': '#f59e0b',
  'Apache Spark': '#f59e0b',
  'Hadoop': '#f59e0b',
  
  // 블록체인/암호화폐
  Blockchain: '#f59e0b',
  Ethereum: '#6b7280',
  'Smart Contracts': '#8b5cf6',
  'Web3': '#f59e0b',
  Solidity: '#6b7280',
  
  // 카테고리별
  '트렌드': '#f59e0b',
  '튜토리얼': '#8b5cf6',
  '리뷰': '#059669',
  '경험담': '#06b6d4',
  '비교': '#ec4899',
  '가이드': '#7c3aed',
  '팁': '#059669',
  '뉴스': '#dc2626',
  '릴리즈': '#8b5cf6',
  '업데이트': '#06b6d4',
  '마이그레이션': '#f59e0b',
  '디버깅': '#dc2626',
  '최적화': '#f59e0b',
  '보안': '#7c2d12',
}
```

## 📋 카테고리 ID 매핑

```typescript
const CATEGORIES = {
  'AI뉴스': {
    id: 'cme5a3ysr0002u8wwwmcbgc7z',
    viewRange: { min: 300, max: 500 }
  },
  'Frontend': {
    id: 'cmdrfyb5f0000u8fsih05gxfk', 
    viewRange: { min: 100, max: 250 }
  },
  'Backend': {
    id: 'cmdrfybll0002u8fseh2edmgf',
    viewRange: { min: 100, max: 250 }
  },
  'DevOps': {
    id: 'cmdrfycij0004u8fs8x3j1k2l',
    viewRange: { min: 80, max: 200 }
  },
  'Database': {
    id: 'cmdrfydgn0006u8fs7h9p4m5n',
    viewRange: { min: 80, max: 180 }
  },
  '오픈소스': {
    id: 'cme5a4pqr0004u8ww2k5m7x8y',
    viewRange: { min: 150, max: 300 }
  },
  '바이브코딩': {
    id: 'cme5a5vyt0003u8ww9aoazx9f',
    viewRange: { min: 300, max: 500 }
  }
}
```

## 📸 이미지 요청 가이드

### 3단계 워크플로우
1. **1차 초안 작성** - 자연스러운 글쓰기 원칙에 따라 완전한 글 작성
2. **이미지 요청** - 사용자에게 필요한 이미지들을 구체적으로 요청
3. **최종 완성** - 받은 이미지를 적절한 위치에 삽입하여 글 완료

### 이미지 요청 템플릿

초안 작성 완료 후 다음과 같이 요청:

```markdown
📝 **글 초안이 완성되었습니다!**

아래 이미지들을 제공해주시면 최종 글을 완성하겠습니다:

🖼️ **필요한 이미지 목록:**
1. **[구체적 이미지 설명 1]** - [어느 섹션에 사용될지]
2. **[구체적 이미지 설명 2]** - [어느 섹션에 사용될지]
3. **[구체적 이미지 설명 3]** - [어느 섹션에 사용될지]

이미지를 제공해주시면 바로 글에 삽입하여 최종 완성본을 만들어드리겠습니다! 📸
```

### 이미지 요청 예시

**AI뉴스 글의 경우:**
```
1. **GPT-5 베타 사용 화면** - 실제 성능 비교 섹션에 사용
2. **기존 GPT-4와 비교 차트** - 성능 개선 부분 설명용
3. **개발자가 코딩하는 모습** - 글 서두 시각적 요소로 사용
```

**Frontend 글의 경우:**
```
1. **React 19 새 기능 코드 스크린샷** - 핵심 기능 설명 부분
2. **성능 비교 그래프** - Before/After 성능 개선 보여주기
3. **실제 프로젝트 적용 화면** - 실전 적용 결과 섹션
```

### 🚨 중요 원칙
- **초안에는 절대 이미지 삽입 금지** - 텍스트로만 완성
- **구체적으로 요청** - "관련 이미지"가 아닌 정확한 설명
- **삽입 위치 명시** - 어느 섹션에 사용될지 설명
- **사용자 응답 후 최종 완성** - 이미지 받으면 바로 삽입

## ✅ AI 에이전트 체크리스트

### 📝 자연스러운 글쓰기 원칙
- [ ] **개인적 시작**: "사실", "솔직히" 등으로 자연스럽게 시작
- [ ] **기계적 나열 금지**: 1,2,3 대신 자연스러운 문단 전개
- [ ] **주관적 표현 활용**: "써보니까", "개인적으로는" 등
- [ ] **감정 표현**: "인상적", "괜찮네요" 등 감정 담기

### 🎯 구조적 자연스러움  
- [ ] **예측 불가한 제목**: 뻔한 패턴 대신 궁금증 유발
- [ ] **대화적 요소**: "어떻게 보세요?", "경험 있으시나요?" 활용
- [ ] **솔직한 평가**: 장단점 모두 솔직하게 전달
- [ ] **초안에는 이미지 삽입 금지** - 텍스트로만 완성

### 🚫 피해야 할 요소들
- [ ] **기계적 호명**: "여러분, 혹시" 같은 뻔한 표현
- [ ] **딱딱한 연결어**: "따라서" 대신 "그런데", "사실" 활용
- [ ] **✅❌ 이분법 정리**: 기계적 구분 최소화
- [ ] **뻔한 마무리**: "도움이 되셨다면" 같은 예측 가능한 결론 금지

## 🛠️ 스크립트 생성 방법

**1. scripts/ 폴더에 새 파일 생성**
```bash
# 예시: Git 설치 가이드
scripts/git-installation-guide.ts
```

**2. 아래 템플릿 사용하여 스크립트 작성**

## 🛠️ 스크립트 템플릿

```typescript
import { prisma } from '@/lib/core/prisma'

const ADMIN_USER_ID = 'cmdri2tj90000u8vgtyir9upy'
const ADMIN_ROLE = 'ADMIN'

const getRandomViewCount = (min: number, max: number) => 
  Math.floor(Math.random() * (max - min + 1)) + min

async function createPost() {
  const content = `# [자연스럽고 궁금증 유발하는 제목]

사실 처음 이 소식을 봤을 때는...

[위의 템플릿 활용하여 자연스러운 글 작성]
`

  try {
    const post = await prisma.mainPost.create({
      data: {
        title: '[자연스럽고 궁금증을 유발하는 제목]',
        slug: 'natural-writing-unique-slug',
        content,
        excerpt: '[개인적 관점이 담긴 자연스러운 요약]',
        status: 'PUBLISHED',
        authorId: ADMIN_USER_ID,
        authorRole: ADMIN_ROLE,
        categoryId: 'cme5a3ysr0002u8wwwmcbgc7z', // AI뉴스
        viewCount: getRandomViewCount(300, 500),
        metaTitle: '[자연스러운 SEO 제목]',
        metaDescription: '[솔직한 의견이 담긴 메타 설명]',
      },
    })

    // 태그 생성 및 연결
    const tags = [
      { name: 'AI', slug: 'ai', color: '#8b5cf6' },
      { name: '트렌드', slug: 'trend', color: '#f59e0b' },
    ]

    for (const tagData of tags) {
      let tag = await prisma.mainTag.findUnique({
        where: { name: tagData.name }
      })

      if (!tag) {
        tag = await prisma.mainTag.create({
          data: {
            name: tagData.name,
            slug: tagData.slug,
            color: tagData.color,
            postCount: 1,
          }
        })
      } else {
        await prisma.mainTag.update({
          where: { id: tag.id },
          data: { postCount: { increment: 1 } }
        })
      }

      await prisma.mainPostTag.create({
        data: {
          postId: post.id,
          tagId: tag.id,
        }
      })
    }

  } catch (error) {
    console.error('게시글 생성 오류:', error)
    throw error
  }
}

if (require.main === module) {
  createPost()
    .then(() => process.exit(0))
    .catch((error) => {
      console.error('스크립트 실행 실패:', error)
      process.exit(1)
    })
}

export { createPost }
```

---

**이 가이드를 따르면 AI가 써도 사람이 쓴 것 같은 자연스러운 글이 나옵니다!**