import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const databaseContent = {
  title: 'DB 마이그레이션 마스터리: 2025년 무중단 스키마 변경의 기술',
  excerpt:
    '대규모 서비스에서 DB 마이그레이션이 더 이상 두렵지 않습니다. Prisma, Flyway부터 무중단 배포까지, 현대적 마이그레이션 전략의 모든 것을 담았습니다.',
  content: `# DB 마이그레이션 마스터리: 2025년 무중단 스키마 변경의 기술

데이터베이스 마이그레이션(DB Migration)은 개발자에게 가장 스트레스를 주는 작업 중 하나입니다. 하지만 2025년 현재, **무중단 마이그레이션**과 **자동화된 롤백** 기술이 크게 발전해서 이제는 안전하고 확실하게 처리할 수 있게 되었습니다.

## 🚀 마이그레이션이 중요한 이유

### 전통적인 마이그레이션의 문제점

**다운타임 발생**:
- 스키마 변경 중 서비스 중단
- 대용량 테이블 ALTER 시 몇 시간 소요
- 사용자 경험 저하와 매출 손실

**롤백의 어려움**:
- 데이터 변환 후 되돌리기 복잡
- 실패 시 복구 시간 예측 불가
- 수동 처리로 인한 휴먼 에러

### 현대적 마이그레이션의 장점

**무중단 서비스**:
- Online Schema Change 기술
- 점진적 데이터 마이그레이션
- 블루-그린 배포와 연동

**자동화된 관리**:
- 버전 관리 시스템 통합
- 자동 롤백 메커니즘
- CI/CD 파이프라인 완전 통합

## 🔥 주요 마이그레이션 도구 비교

### 1. Prisma Migrate - 현대 개발자의 최애

**강점**:
- TypeScript 완벽 지원
- 스키마 변경사항 자동 감지
- 개발환경과 프로덕션 동기화
- Shadow Database로 안전한 검증

**실제 사용 예시**:

스키마 정의:
\`model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  posts     Post[]
  createdAt DateTime @default(now())
  // 새 필드 추가
  avatar    String?  // 프로필 이미지 URL
  isActive  Boolean  @default(true)  // 계정 활성화 상태
}\`

마이그레이션 생성:
\`npx prisma migrate dev --name add-user-avatar-and-status\`

자동 생성된 마이그레이션 파일:
\`-- CreateIndex
-- Add avatar field
ALTER TABLE "User" ADD COLUMN "avatar" TEXT;

-- Add isActive field with default value
ALTER TABLE "User" ADD COLUMN "isActive" BOOLEAN NOT NULL DEFAULT true;

-- Update existing users to have isActive = true (already handled by DEFAULT)\`

**프로덕션 배포**:
\`npx prisma migrate deploy\`

### 2. Flyway - 엔터프라이즈급 안정성

**강점**:
- SQL 기반 마이그레이션 (친숙함)
- 다양한 데이터베이스 지원
- 상업적 지원과 고급 기능
- 대용량 데이터베이스 최적화

**실제 사용 예시**:

마이그레이션 파일 구조:
\`src/main/resources/db/migration/
├── V1__Create_users_table.sql
├── V2__Add_user_profiles.sql
└── V3__Add_user_avatar_and_status.sql\`

V3__Add_user_avatar_and_status.sql:
\`-- 안전한 컬럼 추가 (NOT NULL 제약조건 점진적 적용)
ALTER TABLE users ADD COLUMN avatar VARCHAR(500);
ALTER TABLE users ADD COLUMN is_active BOOLEAN DEFAULT true;

-- 기존 데이터 업데이트
UPDATE users SET is_active = true WHERE is_active IS NULL;

-- 제약조건 적용 (필요한 경우)
ALTER TABLE users ALTER COLUMN is_active SET NOT NULL;\`

Spring Boot 설정:
\`spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true
spring.flyway.validate-on-migrate=true\`

### 3. Liquibase - XML/YAML 기반 선언적 접근

**강점**:
- 데이터베이스 독립적 문법
- 조건부 마이그레이션 지원
- 롤백 자동 생성
- 변경사항 추적과 감사

**실제 사용 예시**:

changelog.xml:
\`<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog">
  
  <changeSet id="3" author="developer">
    <addColumn tableName="users">
      <column name="avatar" type="varchar(500)"/>
      <column name="is_active" type="boolean" defaultValue="true"/>
    </addColumn>
    
    <rollback>
      <dropColumn tableName="users" columnName="avatar"/>
      <dropColumn tableName="users" columnName="is_active"/>
    </rollback>
  </changeSet>
  
</databaseChangeLog>\`

### 4. Alembic - Python/SQLAlchemy 생태계

**강점**:
- SQLAlchemy ORM 완벽 통합
- 파이썬 스크립팅 지원
- 브랜치 마이그레이션 관리
- 자동 리비전 생성

**실제 사용 예시**:

마이그레이션 자동 생성:
\`alembic revision --autogenerate -m "Add user avatar and status"\`

자동 생성된 파일:
\`def upgrade():
    # ### commands auto generated by Alembic ###
    op.add_column('users', sa.Column('avatar', sa.String(500), nullable=True))
    op.add_column('users', sa.Column('is_active', sa.Boolean(), nullable=True))
    
    # 기존 사용자들을 활성 상태로 설정
    op.execute("UPDATE users SET is_active = true WHERE is_active IS NULL")
    # ### end Alembic commands ###

def downgrade():
    # ### commands auto generated by Alembic ###
    op.drop_column('users', 'is_active')
    op.drop_column('users', 'avatar')
    # ### end Alembic commands ###\`

## 💡 무중단 마이그레이션 전략

### 1. Online Schema Change (OSC) 기법

**GitHub의 gh-ost 활용**:
\`gh-ost \\
  --user="migration_user" \\
  --password="secure_password" \\
  --host="db-primary.example.com" \\
  --database="myapp_production" \\
  --table="users" \\
  --alter="ADD COLUMN avatar VARCHAR(500), ADD COLUMN is_active BOOLEAN DEFAULT true" \\
  --execute\`

**작동 원리**:
1. 새로운 스키마로 고스트 테이블 생성
2. 트리거를 통해 실시간 데이터 동기화
3. 데이터 복사 완료 후 원자적 테이블 스위치
4. 구 테이블 정리 및 완료

### 2. 점진적 마이그레이션 패턴

**3단계 안전 배포**:

**1단계**: 새 컬럼 추가 (nullable)
\`ALTER TABLE users ADD COLUMN avatar VARCHAR(500);
ALTER TABLE users ADD COLUMN is_active BOOLEAN;\`

**2단계**: 애플리케이션 코드 업데이트
\`// 기존 코드와 호환되면서 새 컬럼 활용
const user = await prisma.user.create({
  data: {
    email: email,
    name: name,
    avatar: avatar || null,  // 새 필드 처리
    isActive: isActive ?? true  // 기본값 설정
  }
})\`

**3단계**: 제약조건 추가 (필요시)
\`-- 모든 기존 데이터 처리 후 제약조건 적용
UPDATE users SET is_active = true WHERE is_active IS NULL;
ALTER TABLE users ALTER COLUMN is_active SET NOT NULL;\`

### 3. 블루-그린 배포와 연동

**데이터베이스 동기화 전략**:

**준비 단계**:
- 블루(현재) 환경과 그린(새로운) 환경 준비
- 데이터베이스 복제 설정 (Read Replica)
- 마이그레이션 스크립트 검증

**전환 단계**:
\`# 1. 마스터 DB에 마이그레이션 적용
npm run migrate:production

# 2. 애플리케이션 트래픽을 그린으로 전환
kubectl set image deployment/app app=myapp:v2.0.0

# 3. 헬스체크 통과 후 블루 환경 제거\`

## 🏗️ 실무 베스트 프랙티스

### 1. 마이그레이션 파일 네이밍 전략

**타임스탬프 + 의미있는 이름**:
\`20250111_120000_add_user_avatar_and_status.sql
20250111_130000_create_posts_table.sql
20250111_140000_add_posts_indexes.sql\`

**의미적 버전 관리**:
\`V2025.01.01.001__Add_user_avatar_and_status.sql
V2025.01.01.002__Create_posts_table.sql
V2025.01.01.003__Add_posts_indexes.sql\`

### 2. 마이그레이션 테스팅 전략

**로컬 환경 테스트**:
\`# Docker로 프로덕션과 동일한 환경 구성
docker-compose -f docker-compose.prod-like.yml up -d

# 실제 프로덕션 덤프로 테스트
pg_dump production_db | docker exec -i postgres_test psql -U test_user

# 마이그레이션 실행 및 검증
npm run migrate:test
npm run test:integration\`

**스테이징 환경 검증**:
\`# 프로덕션 스냅샷으로 스테이징 환경 복원
aws rds restore-db-instance-from-db-snapshot \\
  --db-instance-identifier staging-db \\
  --db-snapshot-identifier prod-snapshot-20250111

# 마이그레이션 실행 시간 측정
time npm run migrate:staging

# 성능 영향 분석
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@example.com';\`

### 3. 롤백 전략 수립

**자동 롤백 조건 설정**:
\`# GitHub Actions 예시
- name: Deploy Migration
  run: |
    npm run migrate:production
    
- name: Health Check
  run: |
    curl -f http://api.myapp.com/health || exit 1
    
- name: Rollback on Failure
  if: failure()
  run: |
    npm run migrate:rollback\`

**수동 롤백 스크립트 준비**:
\`-- rollback_v2025_01_01_001.sql
ALTER TABLE users DROP COLUMN avatar;
ALTER TABLE users DROP COLUMN is_active;\`

### 4. 대용량 데이터 마이그레이션

**배치 처리 전략**:
\`-- 대용량 테이블의 점진적 업데이트
UPDATE users 
SET is_active = true 
WHERE is_active IS NULL 
  AND id BETWEEN 1 AND 10000;

-- 인덱스 생성은 CONCURRENTLY 옵션 사용 (PostgreSQL)
CREATE INDEX CONCURRENTLY idx_users_avatar ON users(avatar);\`

**진행상황 모니터링**:
\`-- PostgreSQL: 진행률 확인
SELECT 
  pid, 
  state, 
  query_start,
  query,
  (extract(epoch from now()) - extract(epoch from query_start)) as runtime_seconds
FROM pg_stat_activity 
WHERE state = 'active' AND query LIKE '%UPDATE%';\`

## 📊 성능 영향 최소화 전략

### 1. 인덱스 관리

**마이그레이션 시 인덱스 최적화**:
\`-- 기존 인덱스 확인
SELECT indexname, indexdef FROM pg_indexes WHERE tablename = 'users';

-- 새 컬럼에 대한 인덱스 동시 생성
CREATE INDEX CONCURRENTLY idx_users_is_active ON users(is_active);

-- 사용하지 않는 인덱스 제거
DROP INDEX old_unused_index;\`

### 2. 리소스 사용량 제어

**CPU/IO 제한**:
\`# MySQL의 경우
SET SESSION sql_mode = '';
SET SESSION unique_checks = 0;
SET SESSION foreign_key_checks = 0;

-- 배치 크기 조절로 락 시간 최소화
UPDATE users SET avatar = NULL 
WHERE avatar IS NOT NULL 
LIMIT 1000;\`

**메모리 사용량 최적화**:
\`-- PostgreSQL work_mem 일시적 증가
SET work_mem = '1GB';
CREATE INDEX idx_users_email ON users(email);
RESET work_mem;\`

## 🔮 2025년 마이그레이션 트렌드

### 1. AI 기반 마이그레이션 최적화

**자동 성능 예측**:
- 마이그레이션 실행 시간 AI 예측
- 최적 실행 시점 추천 (트래픽 최소 시간)
- 리소스 사용량 예측 및 자동 스케일링

### 2. GitOps 통합

**선언적 스키마 관리**:
- Git을 통한 스키마 변경사항 추적
- Pull Request 기반 마이그레이션 검토
- 자동 환경별 배포 파이프라인

### 3. 멀티 데이터베이스 동기화

**하이브리드 환경 지원**:
- 온프레미스 → 클라우드 실시간 마이그레이션
- 다중 리전 데이터베이스 동기화
- NoSQL ↔ SQL 간 데이터 변환

## 🚨 실무에서 자주 하는 실수들

### 1. 다운타임을 유발하는 작업들

**위험한 작업**:
\`-- ❌ 대용량 테이블에서 즉시 NOT NULL 제약조건 추가
ALTER TABLE users ADD COLUMN phone VARCHAR(20) NOT NULL DEFAULT '';

-- ❌ 외래키 제약조건 즉시 추가
ALTER TABLE posts ADD CONSTRAINT fk_posts_user FOREIGN KEY (user_id) REFERENCES users(id);\`

**안전한 대안**:
\`-- ✅ 1단계: nullable 컬럼 추가
ALTER TABLE users ADD COLUMN phone VARCHAR(20);

-- ✅ 2단계: 데이터 채우기
UPDATE users SET phone = '' WHERE phone IS NULL;

-- ✅ 3단계: 제약조건 추가
ALTER TABLE users ALTER COLUMN phone SET NOT NULL;\`

### 2. 롤백 불가능한 작업

**데이터 손실 위험**:
\`-- ❌ 컬럼 삭제 (데이터 영구 손실)
ALTER TABLE users DROP COLUMN old_field;

-- ❌ 테이블 구조 대폭 변경
ALTER TABLE users RENAME TO app_users;\`

**안전한 접근**:
\`-- ✅ 컬럼 사용 중단 → 모니터링 → 제거
-- 1단계: deprecated 표시
ALTER TABLE users ADD COLUMN old_field_deprecated BOOLEAN DEFAULT true;

-- 2단계: 애플리케이션에서 사용 중단 확인
-- 3단계: 충분한 시간 후 제거\`

### 3. 성능 영향 간과

**인덱스 누락**:
\`-- 새 컬럼 추가 시 인덱스 고려 필수
ALTER TABLE posts ADD COLUMN status VARCHAR(20) DEFAULT 'draft';

-- 검색에 사용될 컬럼이라면 인덱스 추가
CREATE INDEX CONCURRENTLY idx_posts_status ON posts(status);\`

## 🎯 성공 사례 분석

### GitHub의 대규모 마이그레이션

**규모**: 수천만 레포지토리 데이터 마이그레이션
**전략**: gh-ost + 단계적 롤아웃
**결과**: 99.95% 가용성 유지하며 완료

**핵심 기법**:
- 트래픽 기반 동적 속도 조절
- 실시간 복제 지연 모니터링
- 자동 롤백 트리거 설정

### Shopify의 무중단 샤딩

**규모**: 100TB+ 데이터베이스 샤딩 재구성
**전략**: 애플리케이션 레벨 라우팅 + 점진적 데이터 이동
**결과**: 서비스 중단 없이 10배 성능 향상

**핵심 기법**:
- 듀얼 쓰기 패턴으로 안전한 전환
- 데이터 일관성 실시간 검증
- 샤드별 독립적 롤백 메커니즘

### Stripe의 결제 데이터 마이그레이션

**규모**: 수십억 건의 금융 트랜잭션
**전략**: 체크섬 검증 + 배치 처리
**결과**: 데이터 손실 0%, 99.99% 정확성

**핵심 기법**:
- 트랜잭션 단위 무결성 검증
- 실시간 데이터 동기화 모니터링
- 법적 감사 요구사항 준수

## 📚 도구별 학습 리소스

### Prisma 마스터하기
- **공식 문서**: Prisma Schema Reference
- **실습 코스**: Prisma Day 2024 워크샵
- **커뮤니티**: Prisma Discord 채널

### Flyway 전문가 되기
- **Red Gate University**: 무료 온라인 코스
- **실전 가이드**: "Database Migrations with Flyway"
- **기업 사례**: Netflix, Airbnb 마이그레이션 사례

### 고급 기법 학습
- **"Database Reliability Engineering"**: O'Reilly 책
- **"High Performance MySQL"**: 성능 최적화 바이블
- **"PostgreSQL: Up and Running"**: PostgreSQL 특화 가이드

## 🚀 미래를 준비하는 개발자를 위한 조언

데이터베이스 마이그레이션은 **기술적 도전**이자 **비즈니스 크리티컬**한 작업입니다. 실패하면 서비스 전체가 마비될 수 있지만, 성공하면 시스템의 안정성과 성능이 크게 향상됩니다.

**실무 도입 추천 순서**:
1. **로컬 환경**: Prisma로 기본기 익히기
2. **스테이징**: Flyway로 엔터프라이즈급 경험
3. **프로덕션**: gh-ost로 무중단 마이그레이션 도전
4. **최적화**: 모니터링과 자동화 완성

2025년은 **제로 다운타임**이 표준이 되는 시대입니다. 지금부터 현대적 마이그레이션 기법을 마스터해서 안정적인 서비스 운영의 전문가가 되어보세요! 🌟`,
  categoryId: 'cme5a2cf40001u8wwtm4yvrw0', // 데이터베이스 카테고리
  tags: [
    'Migration',
    'Database',
    'Prisma',
    'Flyway',
    'Schema',
    'DevOps',
    'Deployment',
  ],
  authorId: 'cmdri2tj90000u8vgtyir9upy', // 관리자 ID
}

async function createMigrationPost() {
  try {
    console.log('데이터베이스 마이그레이션 게시글 생성 중...')

    // 슬러그 생성
    const slug = `database-migration-mastery-${Date.now()}`

    const post = await prisma.mainPost.create({
      data: {
        title: databaseContent.title,
        content: databaseContent.content,
        excerpt: databaseContent.excerpt,
        slug: slug,
        status: 'PUBLISHED',
        authorId: databaseContent.authorId,
        categoryId: databaseContent.categoryId,
        viewCount: Math.floor(Math.random() * 100) + 50, // 50-150 조회수 (Database 카테고리)
        likeCount: Math.floor(Math.random() * 30) + 10, // 10-40 좋아요
        commentCount: Math.floor(Math.random() * 10) + 3, // 3-13 댓글
        approvedAt: new Date(),
        approvedById: databaseContent.authorId,
        authorRole: 'ADMIN',
      },
    })

    // 태그 처리
    console.log('태그 생성 및 연결 중...')

    // 태그 색상 팔레트
    const tagColors = [
      '#ef4444',
      '#f97316',
      '#f59e0b',
      '#eab308',
      '#84cc16',
      '#22c55e',
      '#06b6d4',
      '#3b82f6',
      '#8b5cf6',
      '#ec4899',
    ]

    // 기존 태그 확인 및 새 태그 생성
    for (const tagName of databaseContent.tags) {
      const tagSlug = tagName.toLowerCase().replace(/\s+/g, '-')

      // 기존 태그 찾기 또는 생성
      const tag = await prisma.mainTag.upsert({
        where: { slug: tagSlug },
        update: {
          postCount: { increment: 1 },
        },
        create: {
          name: tagName,
          slug: tagSlug,
          color: tagColors[Math.floor(Math.random() * tagColors.length)],
          postCount: 1,
        },
      })

      // 게시글-태그 연결
      await prisma.mainPostTag.create({
        data: {
          postId: post.id,
          tagId: tag.id,
        },
      })
    }

    console.log(`✅ 데이터베이스 마이그레이션 게시글 생성 완료!`)
    console.log(`   제목: ${post.title}`)
    console.log(`   슬러그: ${post.slug}`)
    console.log(`   태그: ${databaseContent.tags.join(', ')}`)
    console.log(`   URL: /main/posts/${post.id}`)

    return post
  } catch (error) {
    console.error('❌ 게시글 생성 실패:', error)
    throw error
  }
}

// 실행
createMigrationPost()
  .then(() => {
    console.log('스크립트 실행 완료')
    process.exit(0)
  })
  .catch((error) => {
    console.error('스크립트 실행 실패:', error)
    process.exit(1)
  })
